/**
 * Security Middleware Module
 * Implements advanced security measures for the Express application
 */

import express from 'express';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import bodyParser from 'body-parser';
import session from 'express-session';
import cookieParser from 'cookie-parser';
import cors from 'cors';
import crypto from 'crypto';
import logger from '../utils/logger/index.js';

// Security configuration
const securityConfig = {
    session: {
        secret: process.env.SESSION_SECRET || 'mycrypto-dev-secret-key-change-in-production',
        name: 'sessionId',
        cookie: {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: parseInt(process.env.SESSION_MAX_AGE) || 86400000
        },
        resave: false,
        saveUninitialized: false
    },
    rateLimit: {
        windowMs: parseInt(process.env.RATE_LIMIT_WINDOW) || 900000, // 15 minutes
        max: parseInt(process.env.RATE_LIMIT_MAX_IP) || 100
    },
    cors: {
        origin: process.env.TRUSTED_ORIGINS ? 
            process.env.TRUSTED_ORIGINS.split(',') : 
            ['http://localhost:8080'],
        methods: ['GET', 'POST'],
        credentials: true,
        maxAge: parseInt(process.env.CORS_MAX_AGE) || 86400
    },
    bodyParser: {
        json: {
            limit: process.env.MAX_PAYLOAD_SIZE || '10kb',
            parameterLimit: parseInt(process.env.MAX_PARAMETER_COUNT) || 100
        }
    },
    helmet: {
        contentSecurityPolicy: {
            directives: {
                defaultSrc: ["'self'"],
                scriptSrc: process.env.CSP_SCRIPT_SRC ? 
                    process.env.CSP_SCRIPT_SRC.split(',').map(src => src === 'self' ? "'self'" : src) : 
                    ["'self'"],
                styleSrc: process.env.CSP_STYLE_SRC ? 
                    process.env.CSP_STYLE_SRC.split(',').map(src => src === 'self' ? "'self'" : src) : 
                    ["'self'", "'unsafe-inline'"],
                imgSrc: process.env.CSP_IMG_SRC ? 
                    process.env.CSP_IMG_SRC.split(',').map(src => src === 'self' ? "'self'" : src) : 
                    ["'self'", "data:", "https:"],
                connectSrc: process.env.CSP_CONNECT_SRC ? 
                    process.env.CSP_CONNECT_SRC.split(',').map(src => src === 'self' ? "'self'" : src) : 
                    ["'self'"],
                fontSrc: process.env.CSP_FONT_SRC ? 
                    process.env.CSP_FONT_SRC.split(',').map(src => src === 'self' ? "'self'" : src) : 
                    ["'self'", "https:", "data:"],
                objectSrc: ["'none'"],
                mediaSrc: ["'self'"],
                frameSrc: ["'none'"]
            }
        },
        hsts: {
            maxAge: parseInt(process.env.HSTS_MAX_AGE) || 31536000,
            includeSubDomains: process.env.HSTS_INCLUDE_SUBDOMAINS === 'true',
            preload: process.env.HSTS_PRELOAD === 'true'
        }
    }
};

// URL validation middleware
const validateUrl = (url) => {
    try {
        const whitelist = process.env.TRUSTED_ORIGINS ? process.env.TRUSTED_ORIGINS.split(',') : ['http://localhost:8080'];
        const parsed = new URL(url);
        return whitelist.includes(parsed.origin);
    } catch (error) {
        return false;
    }
};

// Request validation middleware
const validateRequest = (req, res, next) => {
    // Validate redirect URLs
    if (req.query.redirect && !validateUrl(req.query.redirect)) {
        return res.status(400).json({
            error: 'InvalidRedirect',
            message: 'Invalid redirect URL'
        });
    }

    // Validate content length
    const contentLength = parseInt(req.headers['content-length']);
    const maxSize = parseInt(process.env.MAX_PAYLOAD_SIZE || '10240'); // 10kb default
    if (contentLength > maxSize) {
        return res.status(413).json({
            error: 'PayloadTooLarge',
            message: `Request size ${contentLength} exceeds maximum ${maxSize}`
        });
    }

    // Validate content type
    const contentType = req.headers['content-type'];
    if (req.method === 'POST' && !contentType?.includes('application/json')) {
        return res.status(415).json({
            error: 'UnsupportedMediaType',
            message: 'Content-Type must be application/json'
        });
    }

    next();
};

// Rate limiting middleware
const createRateLimiter = (options = {}) => {
    return rateLimit({
        windowMs: options.windowMs || securityConfig.rateLimit.windowMs,
        max: options.max || securityConfig.rateLimit.max,
        message: {
            error: 'RateLimitExceeded',
            message: 'Too many requests, please try again later'
        },
        standardHeaders: true,
        legacyHeaders: false
    });
};

// Security middleware stack
const securityMiddleware = [
    // 1. Basic security headers
    helmet(securityConfig.helmet),

    // 2. CORS protection
    cors(securityConfig.cors),

    // 3. Cookie parser
    cookieParser(),

    // 4. Session management
    session(securityConfig.session),

    // 5. Body parsing and size limits
    bodyParser.json(securityConfig.bodyParser.json),
    bodyParser.urlencoded({ extended: true, ...securityConfig.bodyParser.json }),

    // 6. Request validation
    validateRequest,

    // 7. Default rate limiting
    createRateLimiter()
];

// Specific rate limiters
const authLimiter = createRateLimiter({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 10 // 10 attempts per window
});

const miningLimiter = createRateLimiter({
    windowMs: 60 * 1000, // 1 minute
    max: parseInt(process.env.MINING_RATE_LIMIT) || 10
});

// Error handling middleware
const errorHandler = (err, req, res, next) => {
    // Log all errors with detailed information
    console.error('Security middleware error:', {
        error: err.message,
        stack: err.stack,
        type: err.type || 'Unknown',
        security: err.security || false,
        ip: req.ip,
        path: req.path,
        method: req.method,
        headers: req.headers,
        query: req.query,
        body: req.body
    });

    // Log to structured logger
    logger.error('Request error', {
        component: 'security',
        error: err.message,
        stack: err.stack,
        path: req.path,
        method: req.method
    });

    // Send safe error response
    res.status(err.status || 500).json({
        error: err.type || 'InternalServerError',
        message: err.public || 'An error occurred',
        path: req.path
    });
};

export const createSecurityMiddleware = () => {
    return [
        // Request tracking
        (req, res, next) => {
            const requestId = crypto.randomUUID();
            req.id = requestId;
            
            // Log request start
            logger.debug('Request received', {
                component: 'security',
                requestId,
                method: req.method,
                url: req.url,
                ip: req.ip,
                userId: req.user?.id
            });

            // Track response time
            const start = process.hrtime();
            
            res.on('finish', () => {
                const [seconds, nanoseconds] = process.hrtime(start);
                const responseTimeMs = seconds * 1000 + nanoseconds / 1000000;
                
                logger.debug('Request completed', {
                    component: 'security',
                    requestId,
                    statusCode: res.statusCode,
                    responseTimeMs: Math.round(responseTimeMs)
                });
            });
            
            next();
        },
        
        // Apply security middleware
        ...securityMiddleware,
        
        // Error handler (should be last)
        errorHandler
    ];
};

// Helper function to sanitize user input
const sanitizeStrings = (obj) => {
    if (!obj) return obj;
    
    if (typeof obj === 'string') {
        return obj.replace(/[<>]/g, '');
    } else if (typeof obj === 'object') {
        for (const key in obj) {
            obj[key] = sanitizeStrings(obj[key]);
        }
    }
    return obj;
};

// Helper function to escape HTML
const escapeHtml = (obj) => {
    if (!obj) return obj;
    
    const escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;'
    };
    
    if (typeof obj === 'string') {
        return obj.replace(/[&<>"'/]/g, char => escapeMap[char]);
    }
    return obj;
};

export default createSecurityMiddleware;
